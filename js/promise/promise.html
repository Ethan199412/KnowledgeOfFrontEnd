<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /** promise 是前端岗位非常重要的技能，
         * 深入理解 promise 是非常重要的，手写
         * 一个 promise 并不简单，其难点在于复杂
         * 的回调以及 this 指向相当有迷惑型，Promise
         * 本身是一个构造函数，构造函数参数 executor 
         * 是一个函数，executor 的参数还是两个
         * 函数，很容易搞乱
         * */

        /**
         * 思路：明确 promise 的三大状态，明确 resolve
         * 和 reject 是 promise 内部的函数，明确 then
         * 里面的回调一定要等状态是 resolved 以后才可以
         * 执行，利用队列来存储 pending 状态的回调，等
         * 状态变成 resolved 了以后统一执行。
         * */

        /**
         * TODO: 增加链式 then
         * */
        const PENDING = 'pending'
        const RESOLVED = 'resolved'
        const REJECTED = 'rejected'

        class MyPromise {
            constructor(executor) {
                executor(this.resolve, this.reject)
            }

            status = PENDING
            value = undefined
            err = undefined
            onResolveQueue = []
            onRejectQueue = []

            resolve = (value) => {
                this.value = value
                this.onResolveQueue.forEach(f => {
                    f(this.value)
                })
                this.status = RESOLVED
            }
            reject = (err) => {
                this.err = err
                this.onRejectQueue.forEach(f => {
                    f(this.value)
                })
                this.status = REJECTED
            }
        }

        MyPromise.prototype.then = function (onResolve, onReject) {
            let promise = this
            /** 
            * 如果已经拿到了结果，那么直接执行 onResolve 函数
            * 并且把结果 resolve 掉，resolve 之后，下一个 then
            * 可以在 then 里面的 onResolve 里面拿到 result 这
            * 个值
            * */
            if (promise.status === RESOLVED) {
                return new MyPromise((resolve, reject) => {
                    let result = onResolve(promise.value)
                    resolve(result)
                })

            } else if (promise.status === REJECTED) {
                return new MyPromise((resolve, reject) => {
                    let result = onReject(promise.err)
                    reject(result)
                })
            }
            /**
             * 如果尚未拿到结果，那么 onResolve 函数并不能立刻执行，
             * 所以当前的 promise 需要用一个队列去存下来下一个 promise
             * executor 的逻辑。当第一个 promise 的状态变成 resolve
             * 的时候，队列里面的 executor 会被拿出来执行
             * */
            else if (promise.status == PENDING) {
                return new MyPromise((resolve, reject) => {
                    promise.onResolveQueue.push(() => {
                        let result = onResolve(promise.value)
                        resolve(result)
                    })
                    promise.onRejectQueue.push(() => {
                        let result = onReject(promise.err)
                        resolve(result)
                    })
                })
            }
        }

        function func() {
            return new Promise(resolve => {
                this.setTimeout(() => {
                    console.log('func')
                    resolve(200)
                }, 200)
            })
        }
        new Promise(resolve => {
            setTimeout(() => {
                resolve(1)
            }, 200)
        }).then(async res => {
            let x = await func()
            console.log(x)
            return x
        }).then(res => {
            console.log(res)
            return res + 1
        })
    </script>
</body>

</html>