<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /** promise 是前端岗位非常重要的技能，
         * 深入理解 promise 是非常重要的，手写
         * 一个 promise 并不简单，其难点在于复杂
         * 的回调以及 this 指向相当有迷惑型，Promise
         * 本身是一个构造函数，构造函数参数 executor 
         * 是一个函数，executor 的参数还是两个
         * 函数，很容易搞乱
         * */

         /**
          * 思路：明确 promise 的三大状态，明确 resolve
          * 和 reject 是 promise 内部的函数，明确 then
          * 里面的回调一定要等状态是 resolved 以后才可以
          * 执行，利用队列来存储 pending 状态的回调，等
          * 状态变成 resolved 了以后统一执行。
          * */ 

          /**
           * TODO: 增加链式 then
           * */
        const PENDING = 'pending'
        const RESOLVED = 'resolved'
        const REJECTED = 'rejected'

        class MyPromise {
            constructor(executor) {
                executor(this.resolve, this.reject)
            }

            status = PENDING
            value = undefined
            err = undefined
            onFulfillQueue = []
            onRejectQueue = []

            resolve = (value) => {
                this.value = value
                this.onFulfillQueue.forEach(f => {
                    f(this.value)
                })
                this.status = RESOLVED
            }
            reject = (err) => {
                this.err = err
                this.onRejectQueue.forEach(f => {
                    f(this.value)
                })
                this.status = REJECTED
            }
        }

        MyPromise.prototype.then = function (onFulfill, onReject) {
            let promise = this
            if (promise.status === RESOLVED) {
                onFulfill(value)
            } else if (promise.status === REJECTED) {
                onReject(err)
            } else if (promise.status == PENDING) {
                promise.onFulfillQueue.push((value) => onFulfill(value))
                promise.onRejectQueue.push((value) => onReject(value))
            }
        }

        new MyPromise((resolve)=>{
            console.log('in executor')
            setTimeout(()=>{
                console.log('in setTimeout')
                resolve(1)
            },300)
        }).then(res=>{
            console.log(res)
        })

        console.log('end')
    </script>
</body>

</html>